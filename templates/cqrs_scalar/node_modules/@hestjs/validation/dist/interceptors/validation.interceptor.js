var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Injectable, } from "@hestjs/core";
import { ValidationException, ValidationPipe } from "../pipes/validation.pipe";
/**
 * å‚æ•°éªŒè¯å…ƒæ•°æ®é”®
 */
const PARAMETER_VALIDATION_KEY = Symbol("parameter:validation");
/**
 * Body éªŒè¯è£…é¥°å™¨
 */
export function Body(dtoClass) {
    return function (target, propertyKey, parameterIndex) {
        const existingMetadata = Reflect.getMetadata(PARAMETER_VALIDATION_KEY, target, propertyKey) || [];
        existingMetadata.push({
            index: parameterIndex,
            dtoClass,
        });
        Reflect.defineMetadata(PARAMETER_VALIDATION_KEY, existingMetadata, target, propertyKey);
        // console.log('ğŸ” Bodyè£…é¥°å™¨: å·²å­˜å‚¨éªŒè¯å…ƒæ•°æ®', {
        //   target: target.constructor.name,
        //   method: String(propertyKey),
        //   parameterIndex,
        //   dtoClass: dtoClass.name
        // });
    };
}
/**
 * Query éªŒè¯è£…é¥°å™¨
 */
export function Query(dtoClass) {
    return function (target, propertyKey, parameterIndex) {
        const existingMetadata = Reflect.getMetadata(PARAMETER_VALIDATION_KEY, target, propertyKey) || [];
        existingMetadata.push({
            index: parameterIndex,
            dtoClass,
        });
        Reflect.defineMetadata(PARAMETER_VALIDATION_KEY, existingMetadata, target, propertyKey);
        // console.log('ğŸ” Queryè£…é¥°å™¨: å·²å­˜å‚¨éªŒè¯å…ƒæ•°æ®', {
        //   target: target.constructor.name,
        //   method: String(propertyKey),
        //   parameterIndex,
        //   dtoClass: dtoClass.name
        // });
    };
}
/**
 * éªŒè¯æ‹¦æˆªå™¨
 */
let ValidationInterceptor = class ValidationInterceptor {
    validationPipe;
    constructor() {
        this.validationPipe = new ValidationPipe({
            whitelist: true,
            forbidNonWhitelisted: false,
            transform: true,
        });
    }
    async intercept(context, next) {
        const httpContext = context.switchToHttp();
        const request = httpContext.getRequest();
        const handler = context.getHandler();
        const target = context.getClass();
        // console.log('ğŸ” ValidationInterceptor: å¼€å§‹éªŒè¯', handler.name);
        // console.log('ğŸ” ValidationInterceptor: context ç±»å‹:', typeof context);
        // console.log('ğŸ” ValidationInterceptor: context é”®:', Object.keys(context));
        // å°è¯•è·å–åŸå§‹çš„ Hono Context
        const honoContext = context.context || request;
        // console.log('ğŸ” ValidationInterceptor: honoContext ç±»å‹:', typeof honoContext);
        // è·å–å‚æ•°éªŒè¯å…ƒæ•°æ®
        const paramValidations = Reflect.getMetadata(PARAMETER_VALIDATION_KEY, target.prototype, handler.name) || [];
        // console.log('ğŸ” ValidationInterceptor: æ‰¾åˆ°å‚æ•°éªŒè¯æ•°é‡:', paramValidations.length);
        // console.log('ğŸ” ValidationInterceptor: æ£€æŸ¥ç›®æ ‡:', target.name, 'æ–¹æ³•:', handler.name);
        // console.log('ğŸ” ValidationInterceptor: å°è¯•è¯»å–å…ƒæ•°æ®é”®:', PARAMETER_VALIDATION_KEY.toString());
        if (paramValidations.length === 0) {
            // console.log('ğŸ” ValidationInterceptor: æ²¡æœ‰æ‰¾åˆ°éªŒè¯å…ƒæ•°æ®ï¼Œè·³è¿‡éªŒè¯');
            return next.handle();
        }
        try {
            // éªŒè¯è¯·æ±‚ä½“å’ŒæŸ¥è¯¢å‚æ•°
            for (const validation of paramValidations) {
                const { dtoClass } = validation;
                // console.log('ğŸ” ValidationInterceptor: éªŒè¯ DTO ç±»:', dtoClass.name);
                // è·å–è¯·æ±‚æ•°æ® - ä¼˜å…ˆä½¿ç”¨ Hono Context
                const body = await this.getRequestBody(honoContext);
                // console.log('ğŸ” ValidationInterceptor: è¯·æ±‚ä½“æ•°æ®:', body);
                if (body && Object.keys(body).length > 0) {
                    // è¿›è¡ŒéªŒè¯
                    // console.log('ğŸ” ValidationInterceptor: å¼€å§‹éªŒè¯æ•°æ®');
                    const validatedData = await this.validationPipe.validate(dtoClass, body);
                    // console.log('ğŸ” ValidationInterceptor: éªŒè¯é€šè¿‡ï¼Œæ•°æ®:', validatedData);
                    // å°†éªŒè¯åçš„æ•°æ®å­˜å‚¨åˆ°è¯·æ±‚ä¸­
                    honoContext.validatedBody = validatedData;
                }
                else {
                    // console.log('ğŸ” ValidationInterceptor: è¯·æ±‚ä½“ä¸ºç©ºï¼Œè·³è¿‡éªŒè¯');
                }
            }
            return next.handle();
        }
        catch (error) {
            // console.log("ğŸ” ValidationInterceptor: éªŒè¯å¤±è´¥:", error);
            if (error instanceof ValidationException) {
                // æŠ›å‡º HTTP å¼‚å¸¸
                const validationError = new Error("Validation failed");
                validationError.status = 400;
                validationError.details = {
                    message: "Validation failed",
                    errors: error.getMessages(),
                    statusCode: 400,
                };
                throw validationError;
            }
            throw error;
        }
    }
    /**
     * è·å–è¯·æ±‚ä½“æ•°æ®
     */
    async getRequestBody(request) {
        try {
            // console.log('ğŸ” getRequestBody: æ£€æŸ¥è¯·æ±‚å¯¹è±¡ç±»å‹:', typeof request);
            // console.log('ğŸ” getRequestBody: è¯·æ±‚å¯¹è±¡é”®:', Object.keys(request || {}));
            // æ£€æŸ¥æ˜¯å¦æ˜¯ Hono Context
            if (request && request.req) {
                // console.log('ğŸ” getRequestBody: æ£€æµ‹åˆ° Hono Contextï¼Œä½¿ç”¨ req.json()');
                const body = await request.req.json();
                // console.log('ğŸ” getRequestBody: ä» Hono Context è·å–åˆ°çš„æ•°æ®:', body);
                return body;
            }
            // ç›´æ¥å°è¯•è°ƒç”¨ json æ–¹æ³•
            if (request && typeof request.json === "function") {
                // console.log('ğŸ” getRequestBody: ä½¿ç”¨ request.json()');
                const body = await request.json();
                // console.log('ğŸ” getRequestBody: ä» request.json() è·å–åˆ°çš„æ•°æ®:', body);
                return body;
            }
            // å¦‚æœå·²ç»è§£æè¿‡äº†ï¼Œç›´æ¥è¿”å›
            if (request && request.body) {
                // console.log('ğŸ” getRequestBody: ä½¿ç”¨å·²è§£æçš„ body:', request.body);
                return request.body;
            }
            // console.log('ğŸ” getRequestBody: æ— æ³•è·å–è¯·æ±‚ä½“ï¼Œè¿”å›ç©ºå¯¹è±¡');
            return {};
        }
        catch (error) {
            // console.log('ğŸ” getRequestBody: è·å–è¯·æ±‚ä½“æ—¶å‡ºé”™:', error);
            return {};
        }
    }
};
ValidationInterceptor = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [])
], ValidationInterceptor);
export { ValidationInterceptor };
//# sourceMappingURL=validation.interceptor.js.map